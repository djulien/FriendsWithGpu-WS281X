//vertex shader:
#include "preamble.glsl"

//effect generation (color selection) should be done in here, *not* in fragment shader
//runs once per vertex, which is ~ 500 - 1000x less than fragment shader

//There is an interesting GLSL compiler/disassembler at the link below.
//It is a Windows tool, but it seems to run okay on Wine on Ubuntu as well:
//	http://gpuopen.com/archive/gpu-shaderanalyzer/

//attribute vec3 aVertexPosition;
//attribute vec4 aVertexColor;
//attribute vec2 aTextureCoord;
//varying vec2 vTextureCoord;
attribute vec3 vXYZ; //3D view (x, y, z); for 3D viewer
attribute vec3 hUNM; //hw (univ#, node#, model#); use this for "whole house" effects
attribute vec4 mXYWH; //model (x, y, w, h); use this for model-specific effects

uniform mat4 uModelView;
uniform mat4 uProjection;
uniform float elapsed, duration; //progress bar
//uniform float outmode;
uniform sampler2D uSampler; //texture (individual pixel colors) from caller
uniform bool WS281X_FMT; //allow turn on/off at run-time for debug purposes

varying vec4 vColor; //vertex color data for fragment shader (final formatting)
varying vec4 vColor24; //pivoted color data for fragment shader (final formatting)
//varying vec3 vecpos;
//varying float thing;

//varying vec2 txcoord;
#ifdef CUSTOM_GPUFX
vec4 gpufx(vec3 selector); //fwd ref
#endif //CUSTOM_GPUFX

//CAUTION: GLSL cpp bug is expanding the "x" in "gpufx", so use different param name

#define SAMPLE(x, y) \
    texture2D(uSampler, vec2(float(x) / MAX_UNIV, float(y) / UNIV_MAX))
#define SAMPLEx(x, y)  (x < 8)? SAMPLE(x, y): vec4(0)
//#define SAMPLEx(x, y)  SAMPLE(mod(float(x), 8.0), y)

//#define SAMPLE_OR_FX(var, ex, y) \
//    var = texture2D(uSampler, vec2(ex / MAX_UNIV, y / UNIV_MAX)); \
//    var = IIF(var.a == GPUFX.a, gpufx(var.rgb), var)
//#define SAMPLE_OR_FX_BIT(var, x, y, bit) \
//    SAMPLE_OR_FX(var, x, y); \
//    var = IIF(IFBIT(var, bit), MASK(x), ZERO)

//#define SAMPLE_RGB777(var1, var2, var3, x, y) \
//    SAMPLE(var1, x, y); \
//    var3 = var2 = var1
//   #define mediump //16-bit float: 1 sign + 5 exp + 10 mantissa


void main(void)
{
    gl_Position = uProjection * (uModelView * vec4(vXYZ, 1.0)); //[-1..1]
//#ifdef WS281X_FMT //format as WS281X requires pivot of 24 adjacent bits
    if (WS281X_FMT) //format as WS281X requires pivot of 24 adjacent bits
    {
//ortho projection maps as-is to screen coordinates (except for origin correction):
        float x = floor((gl_Position.x + 1.0) * NUM_UNIV / 2.0); //[0..24)
        float y = floor((gl_Position.y + 1.0) * UNIV_LEN / 2.0); //[0..1152)
//get other pixels on this row:
        vec4 nabe0 = SAMPLE(0, y);
        vec4 nabe1 = SAMPLE(1, y);
        vec4 nabe2 = SAMPLE(2, y);
        vec4 nabe3 = SAMPLE(3, y);
        vec4 nabe4 = SAMPLE(4, y);
        vec4 nabe5 = SAMPLE(5, y);
        vec4 nabe6 = SAMPLE(6, y);
        vec4 nabe7 = SAMPLE(7, y);
//NOTE: RPi reports memory errors (0x505) with > 8 Texture lookups :(
//As a work-around, only 8 values are retrieved here and the rest are set to 0.
//This limits CPU-generated effects to 8 universes, while GPU-generated can be 24.
//Other options are to repeat first 8 values, use color indexing, or pack more colors with less depth,
//but the primary use case is for effects generated on the GPU anyway so this is not worth the effort.
        vec4 nabe8 = SAMPLEx(8, y);
        vec4 nabe9 = SAMPLEx(9, y);
        vec4 nabe10 = SAMPLEx(10, y);
        vec4 nabe11 = SAMPLEx(11, y);
        vec4 nabe12 = SAMPLEx(12, y);
        vec4 nabe13 = SAMPLEx(13, y);
        vec4 nabe14 = SAMPLEx(14, y);
        vec4 nabe15 = SAMPLEx(15, y);
        vec4 nabe16 = SAMPLEx(16, y);
        vec4 nabe17 = SAMPLEx(17, y);
        vec4 nabe18 = SAMPLEx(18, y);
        vec4 nabe19 = SAMPLEx(19, y);
        vec4 nabe20 = SAMPLEx(20, y);
        vec4 nabe21 = SAMPLEx(21, y);
        vec4 nabe22 = SAMPLEx(22, y);
        vec4 nabe23 = SAMPLEx(23, y);
#ifdef CUSTOM_GPUFX //generate effects on GPU directly:
//pass CPU values to GPU allow CPU to influence effects generated by GPU:
//    vColor = IIF(vColor.a == 0.0), gpufx(vColor.rgb), vColor);
//        if (nabe0.a == 0.0) //transparency; let GPU fx show through
//TODO: use gpufx().a for blending?
        nabe0 = gpufx(nabe0.rgb);
        nabe1 = gpufx(nabe1.rgb);
        nabe2 = gpufx(nabe2.rgb);
        nabe3 = gpufx(nabe3.rgb);
        nabe4 = gpufx(nabe4.rgb);
        nabe5 = gpufx(nabe5.rgb);
        nabe6 = gpufx(nabe6.rgb);
        nabe7 = gpufx(nabe7.rgb);
        nabe8 = gpufx(nabe8.rgb);
        nabe9 = gpufx(nabe9.rgb);
        nabe10 = gpufx(nabe10.rgb);
        nabe11 = gpufx(nabe11.rgb);
        nabe12 = gpufx(nabe12.rgb);
        nabe13 = gpufx(nabe13.rgb);
        nabe14 = gpufx(nabe14.rgb);
        nabe15 = gpufx(nabe15.rgb);
        nabe16 = gpufx(nabe16.rgb);
        nabe17 = gpufx(nabe17.rgb);
        nabe18 = gpufx(nabe18.rgb);
        nabe19 = gpufx(nabe19.rgb);
        nabe20 = gpufx(nabe20.rgb);
        nabe21 = gpufx(nabe21.rgb);
        nabe22 = gpufx(nabe22.rgb);
        nabe23 = gpufx(nabe23.rgb);
#endif //def CUSTOM_GPUFX
//pivot 24 RGB888 colors onto 24 parallel GPIO pins by recombining bits:
        vColor24 = BLACK;
        vec3 xmask = MASK3f(x);
        vColor24.rgb += AND3(nabe0.rgb, xmask) * MASK3f(0);
        vColor24.rgb += AND3(nabe1.rgb, xmask) * MASK3f(1);
        vColor24.rgb += AND3(nabe2.rgb, xmask) * MASK3f(2);
        vColor24.rgb += AND3(nabe3.rgb, xmask) * MASK3f(3);
        vColor24.rgb += AND3(nabe4.rgb, xmask) * MASK3f(4);
        vColor24.rgb += AND3(nabe5.rgb, xmask) * MASK3f(5);
        vColor24.rgb += AND3(nabe6.rgb, xmask) * MASK3f(6);
        vColor24.rgb += AND3(nabe7.rgb, xmask) * MASK3f(7);
        vColor24.rgb += AND3(nabe8.rgb, xmask) * MASK3f(8);
        vColor24.rgb += AND3(nabe9.rgb, xmask) * MASK3f(9);
        vColor24.rgb += AND3(nabe10.rgb, xmask) * MASK3f(10);
        vColor24.rgb += AND3(nabe11.rgb, xmask) * MASK3f(11);
        vColor24.rgb += AND3(nabe12.rgb, xmask) * MASK3f(12);
        vColor24.rgb += AND3(nabe13.rgb, xmask) * MASK3f(13);
        vColor24.rgb += AND3(nabe14.rgb, xmask) * MASK3f(14);
        vColor24.rgb += AND3(nabe15.rgb, xmask) * MASK3f(15);
        vColor24.rgb += AND3(nabe16.rgb, xmask) * MASK3f(16);
        vColor24.rgb += AND3(nabe17.rgb, xmask) * MASK3f(17);
        vColor24.rgb += AND3(nabe18.rgb, xmask) * MASK3f(18);
        vColor24.rgb += AND3(nabe19.rgb, xmask) * MASK3f(19);
        vColor24.rgb += AND3(nabe20.rgb, xmask) * MASK3f(20);
        vColor24.rgb += AND3(nabe21.rgb, xmask) * MASK3f(21);
        vColor24.rgb += AND3(nabe22.rgb, xmask) * MASK3f(22);
        vColor24.rgb += AND3(nabe23.rgb, xmask) * MASK3f(23);
    }
//#else //just get one pixel
//    else //just get one pixel
//    {
//#ifdef WS281X_DEBUG //show original color and debug info
//map to WS281X node:
    float hw_univ = hUNM.s; //[0..NUM_UNIV)
    float hw_node = hUNM.t; //[0..UNIV_LEN)

//        SAMPLE_OR_FX(vColor, hw_univ, hw_node);
    vColor = SAMPLE(hw_univ, hw_node);
#ifdef CUSTOM_GPUFX //get colors from GPU:
    vColor = gpufx(vColor.rgb);
#endif //def CUSTOM_GPUFX
//#endif //def WS281X_DEBUG
//    }
//#endif //def WS281X_FMT
   gl_PointSize = PTSIZE; //max(NODEBIT_WIDTH, NODE_HEIGHT); //PTSIZE;
}


/*
#ifndef CUSTOM_GPUFX
//dummy effects generator:
//placeholder for caller-supplied gpufx
vec4 gpufx(vec3 selectfx)
{
    return MAGENTA;
}
#endif //CUSTOM_GPUFX
*/


#if 0
//example effects generator:
function one_by_one(selector)
{
//hw (univ#, node#, model#):
//these are ints, but used in floating arithmetic so just leave them as floats
    float hw_univ = hUNM.s;
    float hw_node = hUNM.t;
    float hw_model = hUNM.p;
//model (x, y, w, h):
    int model_x = int(mXYWH.x);
    int model_y = int(mXYWH.y);
    int model_w = int(mXYWH.w);
    int model_h = int(mXYWH.z);

    vec4 color = vec4(hsv2rgb(vec3(hw_model / MAX_UNIV, 1.0, 1.0)), 1.0); //choose different color for each column
#define round(thing)  thing  //RPi
//       float node = round(elapsed / duration * NUMW * NUMH); //not floor
    float node_inx = floor(elapsed / duration * (NUM_UNIV * UNIV_LEN - 1.0)); //TODO: round?
    float nodex = floor(node_inx / UNIV_LEN), nodey = mod(node_inx, UNIV_LEN);
    if (GT(hw_univ, nodex) || (EQ(hw_univ, nodex) && GT(hw_node, nodey))) color = BLACK;
//color = vec4(elapsed / duration, elapsed / duration, 1.0, 1.0); //CYAN;
    return color;
#endif //0


#if 0
//no switch stmt in GLSL 1.2, so use IIF to avoid branching:
//    int color = int(mod(hw_model, 7.0));
//    vColor = BLACK;
//    vColor = IIF(color == 0, RED, vColor);
//    vColor = IIF(color == 1, GREEN, vColor);
//    vColor = IIF(color == 2, BLUE, vColor);
//    vColor = IIF(color == 3, YELLOW, vColor);
//    vColor = IIF(color == 4, CYAN, vColor);
//    vColor = IIF(color == 5, MAGENTA, vColor);
//    vColor = IIF(color == 6, WHITE, vColor);
//    if (LT(elapsed, 0.0) || GE(elapsed, duration)) //get color from texture
//    {
//        vColor = texture2D(uSampler, vec2((hw_univ + 0.1) / NUMW, hw_node / NUMH));
//first check if CPU wants to set color:
    vColor = texture2D(uSampler, vec2(hw_univ / MAX_UNIV, hw_node / UNIV_MAX)); //[0..1]
//        txcoord = vec2(hw_univ / (NUM_UNIV - 1.0), hw_node / (UNIV_LEN - 1.0)); //[0..1]
//no        vColor = texture2D(uSampler, vec2(hw_univ, hw_node)); //[0..size]
//        vColor = texture2D(uSampler, vec2(0.0, 0.0)); //[0..1]
//        vColor.a = 1.0;
//        vColor.r = 1.0;
//        vColor = total; // / 24.0;
//    }
//if not, then apply GPU fx:
    vColor = IIF(vColor.a == 0.0), gpufx(vColor.rgb), vColor);
//    else //use effect logic to generate color
//    {
        vColor = vec4(hsv2rgb(vec3(hw_model / NUM_UNIV, 1.0, 1.0)), 1.0); //choose different color for each model
#define round(thing)  thing  //RPi
//       float node = round(elapsed / duration * NUMW * NUMH); //not floor
       float node_inx = round(elapsed / duration * NUM_UNIV * UNIV_LEN); //TODO: round?
       float nodex = floor(node_inx / UNIV_LEN), nodey = mod(node_inx, UNIV_LEN);
       if (GT(hw_univ, nodex) || (EQ(hw_univ, nodex) && GT(hw_node, nodey))) vColor = BLACK;
//    }
//    if (hUNM.y > nodey) vColor = BLACK;
//    vColor = vec4(vxyz, 1.0);
//    vColor = vec4(0.0, 0.5, 0.5, 1.0);
//    vColor = vec4(vxyz, 1.0);
//    vTextureCoord = aTextureCoord;
//    vecpos = aVertexPosition;
//    vecpos = vec3(vxyz);
//    if (outmode == 0.0) gl_PointSize = min(NODEBIT_WIDTH, NODE_HEIGHT);
//    else gl_PointSize = NODEBIT_WIDTH; //TODO: screen_width / 23.25
#endif //0

//eof
